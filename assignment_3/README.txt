This assignment was to implement 3 tools:
    1) a file access logging tool (logger.c)
    2) a log monitoring tool (acmonitor.c)
    3) a testing tool to verify the proper function of the above tools
       (test_aclog.c)

1) The file access logging tool overrides the fopen() and fwrite()
   functions of C's stdio.h library. This is done by setting the
   LD_PRELOAD environment variable to the binary of the tool before
   running any program whose file accesses we want to log. The modified
   fopen() and fwrite() log information about the action that's being
   performed and the user that is performing it. The file that the
   logs are stored in is file_logging.log (customizable through the
   LOGFILE_NAME macro) and it is encrypted using RSA encryption. The
   keys that are used are specified below (see NOTES) and the tool that
   encrypts the file is  rsa_tool.c, which was developed as the first
   assignment of this course.
2) The log monitoring tool has 2 modes of operation. It can:
     - detect incidents where "malicious users" tried to access files
       that they were not able to more than 7 times and print the UIDs
       of those "malicious users"
     - detect and output the times each user has modified a specified
       file (modification is checked throught the MD5 checksum of the
       file)
3) The testing tool creates/opens/modifies files, in a way that creates
   the conditions that the “acmonitor.c” tool searches for.





COMPILATION / EXECUTION INSTRUCTIONS:
    All tools and necessary code can be compiled and be ready to run by
    running make.

    Keys have to be generated by running:
        > rsa_assign_1 -g

    In order to verify that all tools are working as intended run:
        > LD_PRELOAD=./logger.so ./test_aclog
        > ./acmonitor -i file1 (or file2,3,4,..., check ls)
        > ./acmonitor -m





NOTES:
    - In order for the tools to run properly, the following keys must be
      present in the directory that the tools are being run:
        private.key     (containing "407 7")
        public.key      (containing "407 103")
      Other keys can be generated by running the RSA tool in key generation
      mode:
        rsa_assign_1 -g
    - In order to make the development of the monitoring tool (acmonitor.c) easier
      and quicker, a new data structure and a set of functions that provide an interface
      to it had to be implemented. The code for this structure is found in dict.h and
      dict.c. This structure is a linked list of so-called dict_items, and the interface
      surrounding it kind of resembles that of Python dictionaries (thus the name) in the
      sense that one can search by a key and get/update a value associated with it, however
      there is close to nothing else in common between the two.
    - Modifications were made to the RSA tool developed in assignment 1 (rsa_tool.c) in order to be
      able to handle the case of the output file being the same as the input file successfully. (The
      way that was achieved is by creating a temporary file where the output is written to, the contents
      of which are then copied back into the original file. The temporary file is deleted.)
    - The logger assumes that every time but the first that it is run, the log file is encrypted and
      attempts to decrypt it. The file existing and being in cleartext may result in unexpected behaviour.
    - Due to the RSA tool using fopen() and fwrite(), the calls to encrypt and decrypt the log file
      resulted in infinite recursions (fopen() calls logger, logger calls RSA tool, RSA tool calls
      fopen()). In order to avoid that a check was added in the start of the fopen() and fwrite() functions
      to allow calls that refer to the files that the RSA tools needs to go through without logging. 
      As a result, accesses on the logfile and the key files used for encryption and decryption are not
      logged.
      A better solution to this would be to modify the RSA tool to use syscalls directly instead of
      fopen() and fwrite(), although due to lack of sufficient time this was not implemented. 
    - In the case of fopen() being called on a non-existent file on read mode, the access_denied flag
      is not set, although the user did not gain access to the file, because the reason for the access
      denial was not permission related.
    - Permission is considered denied also when fwrite is called on a file with only read priviledges.
    - The stream pointer passed to fwrite is assumed to be valid (non-null)
    - The hash in the case of fwrite is calculated after the new data has been written
    - All tools were successfully compiled using gcc (Ubuntu 9.4.0-1ubuntu1~20.04.1) 9.4.0





SOURCES:
    - For dynamic linking and preloading:
        https://man7.org/linux/man-pages/man3/dlsym.3.html
        https://man7.org/linux/man-pages/man8/ld.so.8.html
        https://www.cprogramming.com/tutorial/shared-libraries-linux-gcc.html

    - For time related stuff:
        https://man7.org/linux/man-pages/man3/ctime.3.html
        https://man7.org/linux/man-pages/man3/localtime.3p.html
        https://man7.org/linux/man-pages/man3/strftime.3.html

    - For uid/login:
        https://man7.org/linux/man-pages/man2/getuid.2.html
        https://man7.org/linux/man-pages/man3/getpwuid.3p.html
        https://man7.org/linux/man-pages/man3/getlogin.3.html

    - For fwrite, fopen details:
        https://man7.org/linux/man-pages/man3/fwrite.3p.html
        https://man7.org/linux/man-pages/man3/fopen.3.html
        https://man7.org/linux/man-pages/man2/access.2.html

    - For OpenSSL MD5 checksum stuff:
        https://www.openssl.org/docs/man1.1.1/man3/MD5_Final.html

    - For reading with syscalls and not stdio.h functions:
        https://man7.org/linux/man-pages/man2/open.2.html
        https://man7.org/linux/man-pages/man2/read.2.html
        https://man7.org/linux/man-pages/man2/lseek.2.html
        https://man7.org/linux/man-pages/man3/getline.3.html

    - For parsing command-line arguments:
        https://man7.org/linux/man-pages/man3/getopt.3.html

    - For splitting string with delimeters:
        https://man7.org/linux/man-pages/man3/strtok.3.html





OBSERVATIONS:
    - If the logger runs with the same priviledges as the user calling the fopen, how can it access
      the file and hash it if the user cannot? If it runs with more priviledges than the user calling
      fopen, and the call to the original fopen is made inside the logger, returning the result back
      to the user, is that not a security risk? That the user might be able to access something that
      they shouldn't, since the actual fopen is called with "elevated" priviledges?
